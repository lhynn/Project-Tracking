内嵌汇编的方法：
	int a = 0; 
	int b = 0;
	int d = 100;
	__asm__　＿volatile__(
		"mov r0,#30\n"			//汇编是以换行符来识别一条指令“\n”
		
		"mov %a,#10\n"			//mov 第一个参数应该为寄存器
						//a 为变量a的别名，
						//%a 自动分配空闲的寄存器使用
						//通过别名对变量a的使用


		"mov %0,#20\n"			//通过编号对变量a的使用	

		"mov %0,%2\n"
		//声明输出变量， 只能写不能读
		:[a]"=&r"(a) [b]"=&r"(b)	 //编号是从0递增			
		 编号 0		1			
						 
		//声明输入变量 	 只能读不能写
		:[d]"r"(d)			
		   2		

		//保护寄存器
		:r0				//恢复改变寄存器的值，进行保护
	);

1. r -> register 让变量对应一个寄存器
2. = -> 输出
3. & -> 输出变量不和输入变量公用一个寄存器
4. "+r"(b) b为输入输出变量

/*定义寄存器变量*/
unsigned int register a asm("r5");


立即数规则：
	1.本身小于等于255
	2.经循环右移偶数位之后小于等于255	
 	3.特殊情况
			32位 
			     [20]     	[4]  	     [8] 

			前20存指令 4位存右移位数 后8位存立即数
			0xff >> 32 - 移位数 * 2  ----->0xff00

CPSR_C 溢出标致位		 

	C减法：
		1.有借位 	C = 0
		2.没有借位	C = 1
	C加法：
		1.有进位	C = 1
		2.没有借位	C = 0

乘除法：
	arm7、9、11、cortex-9 都不支持硬件除法 / 、%  

		转换成 >>  -
	
	arm-cortex-a53  arm-cortex-m3/4 支持硬件除法


MUL  %0,，%1，%2 	乘法 必须是寄存器

	卷积	mla 可以做加法也可以做乘法
			mla %0,r0,r1,r2			---->%0 = r2 + r1 * r0
		操作数全是寄存器

除法：	   div		udiv无符号	 sdiv有符号 

比较指令： cmp
		CPSR :	eq -> 等于条件
				N = 0,Z = 1
			ne -> 不相等				
				Z = 0
			lt -> 小于
				N = 1,Z = 0
			gt -> 大于
				N = 0,Z = 0;
			le -> 小于或等于
				N = 1，Z = 0 | N = 0 Z = 1
			ge ->大于等于
				N = 0,Z = 0  | N = 0,Z = 1
			ne  ->不相等

	
		subs  %0,%1,%2\n	==	cmps %1,%2\n
		movlt %0,#1\n		
		movgt %0,#2\n	
		moveq %0,#3\n	
	teq
		teq  %0,%1  == %0 ^ %1
		
		专门比较两个数是否相等

	
